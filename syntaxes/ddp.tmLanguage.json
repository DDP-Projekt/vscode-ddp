{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"scopeName": "source.ddp",
	"patterns": [
		{
			"include": "#comments"
		},
		{
			"include": "#function"
		},
		{
			"include": "#literals"
		},
		{
			"include": "#operators"
		},
		{
			"include": "#types"
		},
		{
			"include": "#keywords"
		}
	],
	"repository": {
		"comments": {
			"patterns": [
				{
					"name": "comment.block.ddp",
					"begin": "\\[",
					"end": "\\]",
					"patterns": [
						{
							"include": "#comments"
						}
					]
				}
			]
		},
		"keywords": {
			"patterns": [
				{
					"name": "keyword.control.ddp",
					"match": "\\b(([Ww]enn)|(dann)|([Ss]onst)|(aber)|([Ff](ü|(ue))r)|(jede[n])|(in)|([Ss]olange)|([Mm]ache)|(zur(ü|(ue))ck)|([Gg]ib)|([Vv]erlasse die Funktion)|(von)|(vom)|(bis)|(jede)|(jeder)|(Schrittgr(ö|(oe))(ß|(ss))e))\\b"
				},
				{
					"name": "meta.preprocessor",
					"match": "Binde (\"[\\s\\S]+\") ein",
					"captures": {
						"1": {
							"name": "meta.preprocessor.string"
						}
					}
				},
				{
					"name": "keyword.ddp",
					"match": "\\b([Dd]er)|([Dd]ie)|([Dd]as)|(de[mn])|(ist)|(an)|(Stelle)|(Funktion)|(Parameter[n])|([Ss]peichere das Ergebnis von)|([Ss]peichere)|(einer)|(eine)|(leere[n])|(Liste)|(aus)|(bestehend)|(besteht)\\b"
				}
			]
		},
		"operators": {
			"patterns": [
				{
					"name": "keyword.operator.new.ddp",
					"match": "\\b((oder)|(und)|(nicht)|(plus)|(minus)|(mal)|(durch)|(modulo)|(hoch)|(Wurzel)|(logisch)|(kontra)|(gleich)|(ungleich)|(kleiner)|(größer)|(groesser)|(als)|(Logarithmus)|(Betrag)|(Länge)|(Laenge)|(Größe)|(Groesse)|(Sinus)|(Kosinus)|(Tangens)|(Arkussinus)|(Arkuskosinus)|(Arkustangens)|(Hyperbelsinus)|(Hyperbelkosinus)|(Hyperbeltangens)|(um)|(Bit)|(verschoben)|(nach)|(links)|(rechts)|(zur)|(Basis)|(verkettet mit)|([Vv]erringere)|([Ee]rhöhe)|([Ee]rhoehe)|([Tt]eile)|([Vv]ervielfache)|([Ss]ubtrahiere)|([Aa]ddiere)|([Mm]ultipliziere)|([Dd]ividiere)|([Nn]egiere))\\b"
				}
			]
		},
		"types": {
			"patterns": [
				{
					"name": "support.type.ddp",
					"match": "\\b((Zahl)|(Kommazahl)|(Boolean)|(Buchstabe[n])|(Text)|(Zahlen Liste)|(Kommazahlen Liste)|(Boolean Liste)|(Buchstaben Liste)|(Text Liste)|(Zahlen Referenz)|(Kommazahlen Referenz)|(Boolean Referenz)|(Buchstaben Referenz)|(Text Referenz)|(Zahlen Listen Referenz)|(Kommazahlen Listen Referenz)|(Boolean Listen Referenz)|(Buchstaben Listen Referenz)|(Text Listen Referenz))\\b"
				}
			]
		},
		"identifier": {
			"patterns": [
				{
					"name": "variable.name.ddp",
					"match": "\\w+"
				}
			]
		},
		"literals": {
			"patterns": [
				{
					"name": "string.quoted.double.ddp",
					"begin": "\"",
					"end": "\""
				},
				{
					"name": "string.quoted.single.ddp",
					"begin": "'",
					"end": "'"
				},
				{
					"name": "constant.language.boolean.ddp",
					"match": "(wahr)|(falsch)"
				},
				{
					"name": "constant.numeric.ddp",
					"match": "-?(\\d+,?\\d*)"
				},
				{
					"name": "constant.numeric.ddp",
					"match": "\\b((pi)|(e)|(tau)|(phi))\\b"
				}
			]
		},
		"function": {
			"patterns": [
				{
					"name": "keyword.other.ddp",
					"match": "Die Funktion (\\w+) (?:mit de[nm] Parameter[n] (\\w+(?:,\\s*\\w+)*) vom Typ (\\w+(?:,(\\s*\\w+))*), )?gibt ((nichts)|(einen (Zahl|Kommazahl|Text|Boolean|Buchstabe))) zurück, (macht):",
					"captures": {
						"1": {
							"name": "variable.name.ddp"
						},
						"2": {
							"name": "variable.name.ddp"
						},
						"3": {
							"name": "support.type.ddp"
						},
						"5": {
							"name": "support.type.ddp"
						},
						"9": {
							"name": "keyword.control.ddp"
						}
					}
				},
				{
					"name": "keyword.control.ddp",
					"match": "ist in (\"[\\s\\S]+\") definiert",
					"captures": {
						"1": {
							"name": "meta.preprocessor.string"
						}	
					}
				},
				{
					"name": "keyword.control.ddp",
					"match": "[Uu]nd kann so benutzt werden:"
				}
			]
		}
	}
}